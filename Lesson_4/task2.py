"""
2. Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»
"""
from timeit import Timer


def first_test(user_el):
    """Простой алгоритм"""
    x = 0
    i = 2
    result = [2]
    # до тех пор пока простое число по счету не стало равным искомому числу(
    # последовательности)
    while x < user_el:
        i += 1
        j = 2
        while j < i:
            if i % j == 0:
                break
            j += 1
        result.append(i)
        x += 1
    return result[-1]


def sieve_of_eratosthenes(user_len, user_el):
    """
    "Решето Эратосфена"
    Функция находит ряд простых чисел до i-ого элемента
    включительно и возвращает весь ряд чисел.
    # i-тый элемент
    """
    # список заполняется значениями от 0 до user_len
    a = [i for i in range(user_len + 1)]
    # Вторым элементом является единица,
    # которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0

    # начинаем с 3-го элемента
    i = 2
    while i <= user_len:
        # Если значение ячейки до этого не было обнулено,
        # в этой ячейке содержится простое число.
        if a[i] != 0:
            # первое кратное ему будет в два раза больше
            j = i * 2
            while j <= user_len:
                # это число составное, поэтому заменяем его нулем
                a[j] = 0
                # переходим к следующему числу, которое кратно i (оно на i
                # больше)
                j += i
        i += 1

    # Превращая список во множество,
    # избавляемся от всех нулей кроме.
    return [i for i in a if i != 0][user_el]


"""
Алгоритм решета взят из интернета
и немного оптимизирован
"""

TEST1 = Timer('sieve_of_eratosthenes(1547430, 100000)',
              'from __main__ import sieve_of_eratosthenes')
print('performed in', TEST1.timeit(number=1), 'seconds')
TEST2 = Timer('first_test(100000)', 'from __main__ import first_test')
print('performed in', TEST1.timeit(number=1), 'seconds')

"""
Вывод: При n = 10000 разница составляет 0.3 секунды.
При n = 100000 - почти 7 секунд.
Кол-во прогонов = 100.
Возможно, я что-то делаю не так, но поиск очень долгий.
Однако при одном повторе разница 0.021.
Если взять последовательность соответсвующую искомому
элементу, то скорость будет наилучшей.
"""
