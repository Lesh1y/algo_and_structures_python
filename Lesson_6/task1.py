"""
1. Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков. Проанализировать
результат и определить программы с наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи. Результаты анализа вставьте в виде
комментариев к коду. Также укажите в комментариях версию Python
и разрядность вашей ОС.
"""
import copy
from memory_profiler import profile


@profile
def function_1():
    """Значительный инкремент"""
    x = [i for i in range(10000000)]    # list(range(10000000))
    y = copy.deepcopy(x)
    return y


@profile
def first_test(user_el):
    """Простой алгоритм"""
    x = 0
    i = 2
    result = [2]
    # до тех пор пока простое число по счету не стало равным искомому числу(
    # последовательности)
    while x < user_el:
        i += 1
        j = 2
        while j < i:
            if i % j == 0:
                break
            j += 1
        result.append(i)
        x += 1
    return result[-1]


@profile
def sieve_of_eratosthenes(user_len, user_el):
    """
    "Решето Эратосфена"
    Функция находит ряд простых чисел до i-ого элемента
    включительно и возвращает весь ряд чисел.
    # i-тый элемент
    """
    # список заполняется значениями от 0 до user_len
    a = [i for i in range(user_len + 1)]
    # Вторым элементом является единица,
    # которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0

    # начинаем с 3-го элемента
    i = 2
    while i <= user_len:
        # Если значение ячейки до этого не было обнулено,
        # в этой ячейке содержится простое число.
        if a[i] != 0:
            # первое кратное ему будет в два раза больше
            j = i * 2
            while j <= user_len:
                # это число составное, поэтому заменяем его нулем
                a[j] = 0
                # переходим к следующему числу, которое кратно i (оно на i
                # больше)
                j += i
        i += 1

    # Превращая список во множество,
    # избавляемся от всех нулей кроме.
    return [i for i in a if i != 0][user_el]


function_1()
first_test(10000)
sieve_of_eratosthenes(104829, 10000)


"""
Windows 10 Pro x64, Python 3.7
Вывод:
В первой функции мы видим колосальное потребление памяти,
а значит нужно искать способы её оптимизации и стараться
избегать подобных решений. С решетом происходит странное:
казалось бы, оно должно кушать память, однако инкременты
появляются ближе к десятитысячному искомому числу, и они
незначительны, что говорит нам об эффективности данного
подхода. Наивный поиск требует много времени для получения
результатов, уже на этом этапе стоит задуматься об его
эффективности, но наша цель - потребляемая память. Речь
идёт о числах начиная с 5000. На пятитысячном простом
числе инкрементов не выявлено. На 10000 искомом числе
инкрементов не обнаружено. С точки зрения потребления
памяти, алгоритм хорош, но затраченное время на поиск...
"""
